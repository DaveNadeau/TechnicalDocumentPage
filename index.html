<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>C++ Data Structures</title>
  <link rel="stylesheet" href="styles.css">
  <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
</head>
  <body>
    <div class="root">
      <div class="TitleBar" id="titlebar">
        <img id="logo" src="http://gdurl.com/dfMF" alt="logo">
        <img id="cppLogo" src="http://gdurl.com/lizlg" alt="cpp Logo">
        <h1 id="dataStruct">Data Structures</h1>
      </div>
      <nav class="navMenu" id="navbar">
        <header id="navHeader">
          basic structures
        </header>
        <ul id="structWrapper">
          <li id="Llist"><a class="nav-link" href="#list">list</a></li>
          <li id="Larray"><a class="nav-link" href="#array">array</a></li>
          <li id="Lvector"><a class="nav-link" href="#vector">vector</a></li>
          <li id="Lqueue"><a class="nav-link" href="#queue">queue</a></li>
          <li id="LpriQueue"><a class="nav-link" href="#priority-queue">priority-queue</a></li>
          <li id="Lstack"><a class="nav-link" href="#stack">stack</a></li>
        </ul>
      </nav>
      <div class="main">
        <main id="main-doc">
          <section class="main-section" id="list">
            <header class="secHeader">list</header>
            <p>Lists are sequence containers that allow constant time insert and erase
              operations anywhere within the sequence, and iteration in both directions.
              List containers are implemented as doubly-linked lists.  Doubly linked lists
              can store each of the elements they contain in different and unrelated storage
              locations. The ordering is kept internally by the association to each element
              of a link to the element preceding it and a link to the element following it.
              Compared to other base standard sequence containers (array, vector and deque),
              lists perform generally better in inserting, extracting and moving elements
              in any position within the container for which an iterator has already been
              obtained, and therefore also in algorithms that make intensive use of these,
              like sorting algorithms.  The main drawback of lists and forward_lists compared
              to these other sequence containers is that they lack direct access to the elements
              by their position; For example, to access the sixth element in a list, one has to
              iterate from a known position (like the beginning or the end) to that position,
              which takes linear time in the distance between these. They also consume some extra
              memory to keep the linking information associated to each element (which may be an
              important factor for large lists of small-sized elements).</p>
            <code>
              std::list<int> listOfNumbers;<br><br>

              //Inserting elements at end in list <br>
              listOfNumbers.push_back(5);<br>
              listOfNumbers.push_back(6);<br><br>

              //Inserting elements at front in list <br>
              listOfNumbers.push_front(2);<br>
              listOfNumbers.push_front(1);<br><br><br><br>
            </code>
            <p>source: <a href="http://www.cplusplus.com/reference/list/list/"
              target="_blank">http://www.cplusplus.com/reference/list/list/</a><br><br><br></p>
            <li class="return"><a href="#titlebar">Back to Top</a></li>
          </section>
          <section class="main-section" id="array">
            <header class="secHeader">array</header>
            <p>Arrays are fixed-size sequence containers: they hold a specific number of
              elements ordered in a strict linear sequence.  Internally, an array does not
              keep any data other than the elements it contains (not even its size, which is a
              template parameter, fixed on compile time). It is as efficient in terms of storage
              size as an ordinary array declared with the language's bracket syntax ([]). This
              class merely adds a layer of member and global functions to it, so that arrays can
              be used as standard containers.  Unlike the other standard containers, arrays have
              a fixed size and do not manage the allocation of its elements through an allocator:
              they are an aggregate type encapsulating a fixed-size array of elements. Therefore,
              they cannot be expanded or contracted dynamically (see vector for a similar container
              that can be expanded).  Zero-sized arrays are valid, but they should not be
              dereferenced (members front, back, and data).  Unlike with the other containers
              in the Standard Library, swapping two array containers is a linear operation that
              involves swapping all the elements in the ranges individually, which generally is a
              considerably less efficient operation. On the other side, this allows the iterators
              to elements in both containers to keep their original container association.  Another
              unique feature of array containers is that they can be treated as tuple objects: The
              array header overloads the get function to access the elements of the array as if it
              was a tuple, as well as specialized tuple_size and tuple_element types.</p>
            <code>
              int n[ 10 ]; // n is an array of 10 integers <br><br>

              // initialize elements of array n to 0<br>
             for ( int i = 0; i < 10; i++ ) {<br>
                n[ i ] = i + 100; // set element at location i to i + 100 <br>
             }<br>
             cout << "Element" << setw( 13 ) << "Value" << endl;<br><br>

             // output each array element's value <br>
             for ( int j = 0; j < 10; j++ ) {<br>
                cout << setw( 7 )<< j << setw( 13 ) << n[ j ] << endl;<br>
             }<br><br><br><br><br>
            </code>
            <p>source: <a href="http://www.cplusplus.com/reference/array/array/?kw=array"
              target="_blank">http://www.cplusplus.com/reference/array/array/?kw=array</a><br><br><br></p>
            <li class="return"><a href="#titlebar">Back to Top</a></li>
          </section>
          <section class="main-section" id="vector">
            <header class="secHeader">vector</header>
            <p>Vectors are sequence containers representing arrays that can change in size.  Just like
              arrays, vectors use contiguous storage locations for their elements, which means that their
              elements can also be accessed using offsets on regular pointers to its elements, and just
              as efficiently as in arrays. But unlike arrays, their size can change dynamically, with
              their storage being handled automatically by the container.  Internally, vectors use a
              dynamically allocated array to store their elements. This array may need to be reallocated
              in order to grow in size when new elements are inserted, which implies allocating a new array
              and moving all elements to it. This is a relatively expensive task in terms of processing time,
              and thus, vectors do not reallocate each time an element is added to the container.  Instead,
              vector containers may allocate some extra storage to accommodate for possible growth, and thus
              the container may have an actual capacity greater than the storage strictly needed to contain
              its elements (i.e., its size). Libraries can implement different strategies for growth to balance
              between memory usage and reallocations, but in any case, reallocations should only happen at
              logarithmically growing intervals of size so that the insertion of individual elements at the
              end of the vector can be provided with amortized constant time complexity (see push_back).
              Therefore, compared to arrays, vectors consume more memory in exchange for the ability to manage
              storage and grow dynamically in an efficient way.Compared to the other dynamic sequence containers
              (deques, lists and forward_lists), vectors are very efficient accessing its elements (just like
              arrays) and relatively efficient adding or removing elements from its end. For operations that involve
              inserting or removing elements at positions other than the end, they perform worse than the others,
              and have less consistent iterators and references than lists and forward_lists.</p>
            <code>
              vector<int> g1; <br>

              for (int i = 1; i <= 5; i++) <br>
                 g1.push_back(i); <br><br>

             cout << "Output of begin and end: "; <br>
             for (auto i = g1.begin(); i != g1.end(); ++i) <br>
                 cout << *i << " "; <br><br>

             cout << "\nOutput of cbegin and cend: "; <br>
             for (auto i = g1.cbegin(); i != g1.cend(); ++i) <br>
                 cout << *i << " "; <br><br>

             cout << "\nOutput of rbegin and rend: "; <br>
             for (auto ir = g1.rbegin(); ir != g1.rend(); ++ir) <br>
                 cout << *ir << " "; <br><br>

             cout << "\nOutput of crbegin and crend : "; <br>
             for (auto ir = g1.crbegin(); ir != g1.crend(); ++ir) <br>
                 cout << *ir << " "; <br>
            </code>
            <p>source: <a href="http://www.cplusplus.com/reference/vector/vector/?kw=vector"
              target="_blank">http://www.cplusplus.com/reference/vector/vector/?kw=vector</a><br><br><br></p>
            <li class="return"><a href="#titlebar">Back to Top</a></li>
          </section>
          <section class="main-section" id="queue">
            <header class="secHeader">queue</header>
            <p>queues are a type of container adaptor, specifically designed to operate in a FIFO context
              (first-in first-out), where elements are inserted into one end of the container and extracted
              from the other.  queues are implemented as containers adaptors, which are classes that use an
              encapsulated object of a specific container class as its underlying container, providing a specific
              set of member functions to access its elements. Elements are pushed into the "back" of the specific
              container and popped from its "front".  The underlying container may be one of the standard container
              class template or some other specifically designed container class. </p>
            <code>
              void showq(queue <int> gq) <br>
              { <br>
                  queue <int> g = gq; <br>
                  while (!g.empty()) <br>
                  { <br>
                      cout << '\t' << g.front(); <br>
                      g.pop(); <br>
                  } <br>
                  cout << '\n'; <br>
              } <br><br>

              int main() <br>
              { <br>
                  queue <int> gquiz; <br>
                  gquiz.push(10); <br>
                  gquiz.push(20); <br>
                  gquiz.push(30); <br><br>

                  cout << "The queue gquiz is : "; <br>
                  showq(gquiz); <br><br>

                  cout << "\ngquiz.size() : " << gquiz.size(); <br>
                  cout << "\ngquiz.front() : " << gquiz.front(); <br>
                  cout << "\ngquiz.back() : " << gquiz.back(); <br><br>

                  cout << "\ngquiz.pop() : "; <br>
                  gquiz.pop(); <br>
                  showq(gquiz); <br>
            </code>
            <p>source: <a href="http://www.cplusplus.com/reference/queue/queue/?kw=queue"
              target="_blank">http://www.cplusplus.com/reference/queue/queue/?kw=queue</a><br><br><br></p>
            <li class="return"><a href="#titlebar">Back to Top</a></li>
          </section>
          <section class="main-section" id="priority-queue">
            <header class="secHeader">priority-queue</header>
            <p>Priority queues are a type of container adaptors, specifically designed such that its first
              element is always the greatest of the elements it contains, according to some strict weak
              ordering criterion.  This context is similar to a heap, where elements can be inserted at
              any moment, and only the max heap element can be retrieved (the one at the top in the priority
              queue).  Priority queues are implemented as container adaptors, which are classes that use an
              encapsulated object of a specific container class as its underlying container, providing a specific
              set of member functions to access its elements. Elements are popped from the "back" of the specific
              container, which is known as the top of the priority queue.  The underlying container may be any of
              the standard container class templates or some other specifically designed container class.</p>
            <code>
              #include <iostream> <br>
              #include <queue> <br><br>

              using namespace std; <br><br>

              void showpq(priority_queue <int> gq) <br>
              { <br>
                  priority_queue <int> g = gq; <br>
                  while (!g.empty()) <br>
                  { <br>
                      cout << '\t' << g.top(); <br>
                      g.pop(); <br>
                  } br
                  cout << '\n'; <br>
              } <br><br>

              int main () <br>
              { <br>
                  priority_queue <int> gquiz; <br>
                  gquiz.push(10); <br>
                  gquiz.push(30); <br>
                  gquiz.push(20); <br>
                  gquiz.push(5); <br>
                  gquiz.push(1); <br><br>

                  cout << "The priority queue gquiz is : "; <br>
                  showpq(gquiz); <br><br>

                  cout << "\ngquiz.size() : " << gquiz.size(); <br>
                  cout << "\ngquiz.top() : " << gquiz.top(); <br><br>


                  cout << "\ngquiz.pop() : "; <br>
                  gquiz.pop(); <br>
                  showpq(gquiz); <br><br>

                  return 0; <br>
              } <br>
            </code>
            <p>source: <a href="http://www.cplusplus.com/reference/queue/priority_queue/"
              target="_blank">http://www.cplusplus.com/reference/queue/priority_queue/</a><br><br><br></p>
            <li class="return"><a href="#titlebar">Back to Top</a></li>
          </section>
          <section class="main-section" id="stack">
            <header class="secHeader">stack</header>
            <p>Stacks are a type of container adaptor, specifically designed to operate in a LIFO context
              (last-in first-out), where elements are inserted and extracted only from one end of the container.
              stacks are implemented as containers adaptors, which are classes that use an encapsulated object
              of a specific container class as its underlying container, providing a specific set of member
              functions to access its elements. Elements are pushed/popped from the "back" of the specific
              container, which is known as the top of the stack.  The underlying container may be any of the
              standard container class templates or some other specifically designed container class.</p>
            <code>
              std::deque<int> mydeque (3,100);          // deque with 3 elements <br>
              std::vector<int> myvector (2,200);        // vector with 2 elements <br><br>

              std::stack<int> first;                    // empty stack <br>
              std::stack<int> second (mydeque);         // stack initialized to copy of deque <br><br>

              std::stack<int,std::vector<int> > third;  // empty stack using vector <br>
              std::stack<int,std::vector<int> > fourth (myvector); <br><br>

              std::cout << "size of first: " << first.size() << '\n'; <br>
              std::cout << "size of second: " << second.size() << '\n';<br>
              std::cout << "size of third: " << third.size() << '\n'; <br>
              std::cout << "size of fourth: " << fourth.size() << '\n';  <br><br>
            </code>
            <p>source: <a href="http://www.cplusplus.com/reference/stack/stack/?kw=stack"
              target="_blank">http://www.cplusplus.com/reference/stack/stack/?kw=stack</a><br><br><br><br>
              <br><br><br><br><br><br><br><br><br><br><br><br></p>
            <li class="return"><a href="#titlebar">Back to Top</a></li>
          </section>
        </main>
      </div>
    </div>


    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js">
    </script>
    <script type="text/javascript" src="script.js"></script>
  </body>
</html>
